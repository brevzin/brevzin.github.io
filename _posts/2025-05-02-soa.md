---
layout: post
title: "Implementing Struct of Arrays"
category: c++
tags:
 - c++
 - c++26
 - reflection
pubdraft: yes
---

Recently, I watched Andrew Kelley's talk on [Practical Data Oriented Design](https://www.youtube.com/watch?v=IroPQ150F6c). It goes into some of the architectural changes he's been making to the Zig compiler, with pretty significant performance benefit. Would definitely recommend checking out the talk, even if you're like me and have never written any Zig.

About halfway through the talk, he shows a way to improve his memory usage by avoiding wasting memory. By turning this structure:

```zig
const Monster = struct {
    anim : *Animation,
    kind : Kind,

    const Kind = enum {
        snake, bat, wolf, dingo, human
    };
};

var monsters : ArrayList(Monster) = .{};
```

into this one:

```zig
var monsters : MultiArrayList(Monster) = .{};
```

`ArrayList(Monster)` is what we could call `std::vector<Monster>`, and `MultiArrayList(Monster)` now stores the `anim`s and `kind`s in two separate arrays, instead of one. That is, a struct of arrays instead of an array of structs. But it's a *tiny* code change.

> One of the interesting things about Zig to me is that types are first class. Rather than having a class template that takes a template type parameter (like `std::vector` taking `T`), you write a function that takes a function parameter that is a type. That function then returns a type.
>
> The implementation of MultiArrayList is [literally](https://github.com/ziglang/zig/blob/master/lib/std/multi_array_list.zig)
> ```zig
> pub fn MultiArrayList(comptime T: type) type {
>   return struct {
>     // lots of code
>   };
> }
> ```
{:.prompt-info}

The goal of this blog post is to implement the same thing using C++26 Reflection. We're going to write a `SoaVector<T>` that instead being a dynamic array of `T`s has one dynamic array for each non-static data member of `T`.

## We Start with Storage

For the purposes of this post, we're going to pick a simple type that has two members of different types. Let's say... a chess coordinate:

```cpp
struct Point {
    char x;
    int y;
};
```

If we were implementing a simple `Vector<Point>` our storage would look like

```cpp
struct {
    Point* data;
    size_t size;
    size_t capacity;
};
```

But we're writing an `SoaVector<Point>`, which means we want to store the `x`s and `y`s separately. Now, we could be lazy and do this:

```cpp
struct {
    std::vector<char> x;
    std::vector<int> y;
};
```

That would meet the requirements, but it's not a great approach. These two `vector`s always have the same size, capacity — no reason to track them independently. I'm not going to try to produce some optimal, production ready structure in this blog... but let's not prematurely pessimize either.

Instead, we want to do this:

```cpp
struct {
    // a pointer for each non-static data member
    char* x;
    int* y;

    // and then a size/capacity that apply to all of them
    size_t size;
    size_t capacity;
};
```

C++26 Reflection doesn't have a lot on offer when it comes to code generation, but it _does_ have the tools for this. There is a function `define_aggregate()` which lets us... well... define an aggregate. By providing it with the data members we want to generate.

That, coupled with the ability to query data members, is all we need to begin:

```cpp
template <class T>
struct SoaVector {
    struct Pointers;
    consteval {
        define_aggregate(^^Pointers,
            nsdms(^^T)
            | std::views::transform([](std::meta::info member){
                return data_member_spec(add_pointer(type_of(member)),
                                        {.name = identifier_of(member)});
            }));
    }

    Pointers pointers_ = {};
    size_t size_ = 0;
    size_t capacity_ = 0;
};
```

Here, `nsdms` is a convenience helper because the real API is a mouthful:

```cpp
consteval auto nsdms(std::meta::info type) -> std::vector<std::meta::info> {
    return nonstatic_data_members_of(type, std::meta::access_context::current());
}
```

And then, for each non-static data member `T mem` we create a `data_member_spec` whose type is `T*` and whose name is `mem`. I'm choosing to keep the `size_` and `capacity_` members separate, both because it's simpler (why code-gen members I know I need) and also because it makes for nice symmetry (`SoaVector<T>::Pointers` and `T` have the same number of members).

We're off to a nice start.

## Let's Add Some Elements

Of course our storage isn't particularly interesting just sitting there. The next thing to implement is `push_back`. The basic contours of `push_back` for our `SoaVector` are the same as for a regular `Vector`, so we start with the skeleton:

```cpp
auto push_back(T const& value) -> void {
    if (size_ == capacity_) {
        grow(/* some new capacity */);
    }

    // add this element

    ++size_;
}
```

where

```cpp
auto grow(size_t new_capacity) -> void {
    // 1. allocate new storage
    // 2. copy/move into the new storage
    // 3. deallocate the old storage
}
```

Now, both for simplicity and to limit our focus, I'm not going to worry about things like exception safety, and we're just going to copy elements.

We'll start with `grow` first, since it's simpler. And because I'm not worrying about exceptions, we can actually do that sequence of steps for each non-static data member in order

```cpp
auto grow(size_t new_capacity) -> void {
    Pointers new_pointers = {};
    template for (constexpr auto M : /* ??? */) {
        // 1. allocate new storage
        // 2. copy into the new storage
        // 3. deallocate the old storage
    }

    pointers_ = new_pointers;
    capacity_ = new_capacity;
}
```

Now, one of the C++26 limitations is that we can't just do `nsdms(^^Pointers)` in the expansion statement. That requires non-transient allocation, which we don't have. Thankfully, we have a library solution for this in the form of `define_static_array()`. That function creates a static storage array with the contents you pass into it and returns a `std::span` into those contents. That `std::span`, importantly, can be used as a `constexpr` variable (it just points into `static` storage)! This is something that's going to come up repeatedly, so we'll store that in the class itself:

```cpp
template <class T>
struct SoaVector {
    struct Pointers;
    consteval { /* ... */ }
    Pointers pointers_ = {};
    size_t size_ = 0;
    size_t capacity_ = 0;

    static constexpr auto mems = define_static_array(nsdms(^^T));
    static constexpr auto ptr_mems = define_static_array(nsdms(^^Pointers));
};
```
{: data-line="9-10" .line-numbers  }

Which will allow us to implement `grow` (with a couple helper functions for convenience):

```cpp
auto grow(size_t new_capacity) -> void {
    Pointers new_pointers = {};
    template for (constexpr auto M : ptr_mems) {
        // 1. allocate
        new_pointers.[:M:] = allocate<[:remove_pointer(type_of(M)):]>(
            new_capacity);
        // 2. copy
        std::uninitialized_copy_n(pointers_.[:M:], size_, new_pointers.[:M:]);
        // 3. deallocate
        delete_range(pointers_.[:M:]);
    }
    pointers_ = new_pointers;
    capacity_ = new_capacity;
}

template <class U>
auto allocate(size_t cap) -> U* {
    return std::allocator<U>().allocate(cap);
}

template <class U>
auto delete_range(U* ptr) -> void {
    std::destroy(ptr, ptr + size_);
    std::allocator<U>().deallocate(ptr, capacity_);
}
```

Whenever we allocate memory, we have to remember to clean it up. We're doing that to the old storage in `grow` and we have to do it in our destructor too:

```cpp
~SoaVector() {
    template for (constexpr auto M : ptr_mems) {
        delete_range(pointers_.[:M:]);
    }
}
```

Now that we have our memory (and properly cleaning it up too), let's go back to `push_back`. What we need to do is take a `T` and write each member of that `T` into the corresponding array. Reading the source member requires looking at a non-static data member of `T`, while writing the destination member requires looking at a non-static data member of `Pointers`. We could either loop over the number of members, or we could loop over a `zip` of the two sets of members.

I'm going to do the former since clang doesn't yet implement `constexpr` structured bindings:

```cpp
auto push_back(T const& value) -> void {
    if (size_ == capacity_) {
        // some exponential growth
        grow(std::max(3 * size_ / 2, size_ + 2));
    }

    template for (constexpr auto I : std::views::iota(0zu, mems.size())) {
        constexpr auto from = mems[I];
        constexpr auto to = ptr_mems[I];

        using M = [: type_of(from) :];
        ::new (pointers_.[: to :] + size_) M(value.[:from:]);
    }

    ++size_;
}
```

That would actually be simpler if I used `std::construct_at`, since I wouldn't need to determine `M`. But in general I prefer placement new (especially since that'll be `constexpr` in C++26 too) since it can do all kinds of initialization.

So far so good. If I just make everything `public` for [easy debugging](https://godbolt.org/z/GfWYTMn5v):

```cpp
struct Point {
    char x;
    int y;
};

int main() {
    SoaVector<Point> v;
    v.push_back(Point{.x='e', .y=4});
    v.push_back(Point{.x='f', .y=7});

    std::println("x={}", std::span(v.pointers_.x, v.size_)); // x=['e', 'f']
    std::println("y={}", std::span(v.pointers_.y, v.size_)); // y=[4, 7]
}
```

## Reading Those Elements

Now indexing is where things get really interesting. Because what do we return? For the purposes of this blog, we're going to do things two different ways:

* the `const` indexing operator is just going to return a `Point`, by value.
* the mutable indexing operator is going to return a view into a `Point` — a new `PointRef` type.

What I mean by `PointRef` is:

```cpp
struct PointRef {
    char& x;
    int& y;

    auto operator=(Point const&) const -> void; // assigns through
};
```

The point (sorry) here isn't to argue that this is the absolutely correct way to implement `SoaVector<T>`. Maybe you think the `const` indexing operator should return a version of `PointRef` that has `const&`s. Maybe you think there shouldn't even be an indexing operator. I don't know what the right answer is. But doing it this way should show how it's possible to do whatever it is you want to do.

But before we go further, let's add some more debuggability to this project (copying from [this earlier post]({% post_url 2024-09-30-annotations %}#pretty-printing-a-struct)):

```cpp
struct [[=derive<Debug>]] Point {
    char x;
    int y;
};
```
{: data-line="1" .line-numbers  }

Now we can actually print our `Point`s. Much better!

### Indexing into a Value

The first thing we'll do is write

```cpp
auto operator[](size_t idx) const -> T;
```

That'll get us to the point where we can both `push_back` `Point`s into our `SoaVector` and then read `Point`s back out successfully. That's really the bare minimum to be able to claim that we've actually implemented a struct-of-arrays vector.

Now, so far, we've seen several examples where we need to iterate one member at a time. We allocated/deallocated one member at a time, we wrote one member at a time. But reading we can't really do one member at a time. Well, we _could_ — emitting the equivalent of:

```cpp
auto operator[](size_t idx) const -> Point {
    Point p;
    p.x = pointers_.x[idx];
    p.y = pointers_.y[idx];
    return p;
}
```

And for this `Point` type, that's perfectly fine. But let's try for something better. We want to emit:

```cpp
auto operator[](size_t idx) const -> Point {
    return Point{pointers_.x[idx], pointers_.y[idx]};
}
```

The only way in C++26 to do this is to expand a pack. We can use the `index_sequence` trick as usual. Or we can do some reflection-specific. Let's just do the latter, for the sake of doing the latter:

```cpp
auto operator[](size_t idx) const -> T {
    return [: expand_all(ptr_mems) :] >> [this, idx]<auto... M>{
        return T{pointers_.[:M:][idx]...};
    };
}
```

And with that, we have both `push_back` and `operator[]` [working](https://godbolt.org/z/od3Kq6683):

```cpp
struct [[=derive<Debug>]] Point {
    char x;
    int y;
};

int main() {
    SoaVector<Point> v;
    v.push_back(Point{.x='e', .y=4});
    v.push_back(Point{.x='f', .y=7});

    std::println("v[0]={}", v[0]); // v[0]=Point{.x='e', .y=4}
    std::println("v[1]={}", v[1]); // v[1]=Point{.x='f', .y=7}
}
```
### Indexing into a Reference

Let's take the next step. We don't want to just read `v[0]`, we want to be able to write into it. We want to make `v[0] = Point{.x='a', .y=8}` work. How do we do it?

To start with, we need to generate a new type. But now, we don't just want to emit:

```cpp
struct PointRef {
    char& x;
    int& y;
};
```

We also wanted an assignment operator and a conversion operator. `define_aggregate()` doesn't have the ability to generate member functions — only non-static data members. But that's no matter, we can generate those members and then add those member functions in a derived class:

```cpp
template <class T>
struct SoaVector {
private:
    struct Pointers;
    struct RefBase;
    consteval {
        define_aggregate(^^Pointers,
            transform_members(^^T, std::meta::add_pointer));
        define_aggregate(^^RefBase,
            transform_members(^^T, std::meta::add_lvalue_reference));
    }
    Pointers pointers_ = {};
    size_t size_ = 0;
    size_t capacity_ = 0;

    static constexpr auto mems = define_static_array(nsdms(^^T));
    static constexpr auto ptr_mems = define_static_array(nsdms(^^Pointers));
    static constexpr auto ref_mems = define_static_array(nsdms(^^RefBase));

    struct Ref : RefBase {
        auto operator=(T const& value) const -> void;
    };
};
```
{: data-line="5,9-10,18,20-22" .line-numbers  }

The logic for the assignment operator is the same as what we saw in `push_back`, except we're writing through reference members instead of indexed pointer ones:

```cpp
struct Ref : RefBase {
    auto operator=(T const& value) const -> void {
        template for (constexpr auto I : std::views::iota(0zu, mems.size())) {
            this->[:ref_mems[I]:] = value.[:mems[I]:];
        }
    }
};
```

And that's... basically it. The index operator that returns a `Ref` looks nearly the same as the one that returns the `T`, we're just initializing a different thing in a slightly different way:

```cpp
auto operator[](size_t idx) -> Ref {
    return [: expand_all(ptr_mems) :] >> [this, idx]<auto... M>{
        return Ref{pointers_.[:M:][idx]...};
    };
}

auto operator[](size_t idx) const -> T {
    return [: expand_all(ptr_mems) :] >> [this, idx]<auto... M>{
        return T{pointers_.[:M:][idx]...};
    };
}
```

Which gives us:

```cpp
struct [[=derive<Debug>]] Point {
    char x;
    int y;
};

int main() {
    SoaVector<Point> v;
    v.push_back(Point{.x='e', .y=4});
    v.push_back(Point{.x='f', .y=7});

    v[0] = Point{.x='a', .y=8};

    std::println("v[0]={}", std::as_const(v)[0]); // v[0]=Point{.x='a', .y=8}
    std::println("v[1]={}", std::as_const(v)[1]); // v[1]=Point{.x='f', .y=7}
}
```

Which is pretty sweet.

### Formatting the Reference

Well, okay. It feels a bit incomplete right. We should be able to just print `v[0]` and not have to print `std::as_const(v)[0]`! Thankfully, annotations help us out there too. We just have to use them:

```cpp
template <class T>
struct SoaVector {
private:
    struct Pointers;
    struct [[=derive<Debug>]] RefBase;
    consteval { /* ... */ }
    Pointers pointers_ = {};
    size_t size_ = 0;
    size_t capacity_ = 0;

    static constexpr auto mems = define_static_array(nsdms(^^T));
    static constexpr auto ptr_mems = define_static_array(nsdms(^^Pointers));
    static constexpr auto ref_mems = define_static_array(nsdms(^^RefBase));

    struct [[=derive<Debug>]] Ref : RefBase {
        // ...
    };
};
```
{: data-line="5,15" .line-numbers  }

Annotations are _so_ cool.

Anyway, that's great, since it lets us just print `v[0]` instead of `std::as_const(v)[0]`. But it doesn't quite print it [the way I'd like](https://godbolt.org/z/eKKdroTbM):

```cpp
v[0]=Ref{RefBase{.x='a', .y=8}}
v[1]=Ref{RefBase{.x='f', .y=7}}
```

What if we just, at the point of formatting, forced the conversion to `Point`? That requires two things. First, we need to add such a conversion. That's no problem, we've already done that twice:

```cpp
struct [[=derive<Debug>]] Ref : RefBase {
    auto operator=(T const& value) const -> void {
        template for (constexpr auto I : std::views::iota(0zu, mems.size())) {
            this->[:ref_mems[I]:] = value.[:mems[I]:];
        }
    }

    operator T() const {
        return [: expand_all(ref_mems) :] >> [this]<auto... M>{
            return T{this->[:M:]...};
        };
    }
};
```
{: data-line="8-12" .line-numbers  }

And then we add some more functionality to our little formatting annotation library. Right now we just have `derive<Debug>`. We could add some more information there — add _which_ type we want to format as. Let's do something like this. We'll add a new annotation type:

```cpp
struct format_as { std::meta::info type; };
```

Which we'll add to `Ref` (and then remove the `derive<Debug>` from `RefBase` as no longer necessary):

```cpp
template <class T>
struct SoaVector {
private:
    struct Pointers;
    struct RefBase;
    consteval { /* ... */; }
    Pointers pointers_ = {};
    size_t size_ = 0;
    size_t capacity_ = 0;

    // ...

    struct [[=derive<Debug>, =format_as{^^T}]] Ref : RefBase {
        // ...
    };
};
```
{: data-line="5,13" .line-numbers  }

Now we have to teach our annotation-based formatter to just for this other annotation. First, we determine what type we're formatting as:

```cpp
template <class T> requires (has_annotation(^^T, derive<Debug>))
struct std::formatter<T> {
    constexpr auto parse(auto& ctx) { return ctx.begin(); }

    static constexpr auto As = []{
        auto as = annotations_of(^^T, ^^format_as);
        if (not as.empty()) {
            return extract<format_as>(as[0]).type;
        } else {
            return ^^T;
        }
    }();

    auto format([:As:] const& m, auto& ctx) const {
        // ...
    }
};
```
{: data-line="5-12,14" .line-numbers  }

If we have an annotation of type `format_as`, we pull out that type. Otherwise, we're formatting as `T`.

Then, we change the parameter to `format` to take an `[: As :]` instead of a `T` and change the implementation to reflect on `As` instead of `T`:

```cpp
template <class T> requires (has_annotation(^^T, derive<Debug>))
struct std::formatter<T> {
    constexpr auto parse(auto& ctx) { return ctx.begin(); }

    static constexpr auto As = /* ... */;

    auto format([:As:] const& m, auto& ctx) const {
        auto out = std::format_to(ctx.out(), "{}", display_string_of(As));
        *out++ = '{';
        auto delim = [&, first=true]() mutable { /* ... */ };

        template for (constexpr auto base :
                      define_static_array(bases_of(As))) {
            // ...
        }

        template for (constexpr auto nsdm :
                      define_static_array(nsdms(As))) {
            // ...
        };

        *out++ = '}';
        return out;
    }
};
```
{: data-line="7,8,13,18" .line-numbers  }

## A Working Implementation

And with all that said and done, let's look at [this program](https://godbolt.org/z/7dvEjz4sf):

```cpp
struct [[=derive<Debug>]] Point {
    char x;
    int y;
};

int main() {
    SoaVector<Point> v;
    v.push_back(Point{.x='e', .y=4});
    v.push_back(Point{.x='f', .y=7});

    v[0] = Point{.x='a', .y=8};

    std::println("v[0]={}", v[0]); // v[0]=Point{.x='a', .y=8}
    std::println("v[1]={}", v[1]); // v[1]=Point{.x='f', .y=7}
}
```

We're taking an arbitrary type, creating a struct of vectors out of each element, supporting pushing elements into it (handling the piece-wise split ourselves), reading elements out of it (ditto), and even supporting proxy references that print like the original type.

The complete implementation of `SoaVector` here was less than 100 lines of code, plus a few other short helpers. Just pasting the actual implementation (reformatted slightly for the narrower screen):

```cpp
template <class T>
struct SoaVector {
private:
    struct Pointers;
    struct RefBase;
    consteval {
        define_aggregate(
            ^^Pointers,
            transform_members(^^T, meta::add_pointer));
        define_aggregate(
            ^^RefBase,
            transform_members(^^T, meta::add_lvalue_reference));
    }
    Pointers pointers_ = {};
    size_t size_ = 0;
    size_t capacity_ = 0;

    static constexpr auto mems = define_static_array(nsdms(^^T));
    static constexpr auto ptr_mems = define_static_array(nsdms(^^Pointers));
    static constexpr auto ref_mems = define_static_array(nsdms(^^RefBase));

    struct [[=derive<Debug>, =format_as{^^T}]] Ref : RefBase {
        auto operator=(T const& value) const -> void {
            template for (constexpr auto I : views::iota(0zu, mems.size())) {
                this->[:ref_mems[I]:] = value.[:mems[I]:];
            }
        }

        operator T() const {
            return [: expand_all(ref_mems) :] >> [this]<auto... M>{
                return T{this->[:M:]...};
            };
        }
    };

    auto grow(size_t new_capacity) -> void {
        Pointers new_pointers = {};
        template for (constexpr auto M : ptr_mems) {
            new_pointers.[:M:] = alloc<[:meta::remove_pointer(type_of(M)):]>(
                new_capacity);
            uninitialized_copy_n(pointers_.[:M:],
                                 size_,
                                 new_pointers.[:M:]);
            delete_range(pointers_.[:M:]);
        }
        pointers_ = new_pointers;
        capacity_ = new_capacity;
    }

    template <class U>
    auto alloc(size_t cap) -> U* {
        return allocator<U>().allocate(cap);
    }

    template <class U>
    auto delete_range(U* ptr) -> void {
        destroy(ptr, ptr + size_);
        allocator<U>().deallocate(ptr, capacity_);
    }

public:
    SoaVector() = default;
    ~SoaVector() {
        template for (constexpr auto M : ptr_mems) {
            delete_range(pointers_.[:M:]);
        }
    }

    auto push_back(T const& value) -> void {
        if (size_ == capacity_) {
            grow(max(3 * size_ / 2, size_ + 2));
        }

        template for (constexpr auto I : views::iota(0zu, mems.size())) {
            constexpr auto from = mems[I];
            constexpr auto to = ptr_mems[I];

            using M = [: type_of(from) :];
            :: new (pointers_.[: to :] + size_) M(value.[:from:]);
        }

        ++size_;
    }

    auto size() const -> size_t {
        return size_;
    }

    auto operator[](size_t idx) -> Ref {
        return [: expand_all(ptr_mems) :] >> [this, idx]<auto... M>{
            return Ref{pointers_.[:M:][idx]...};
        };
    }

    auto operator[](size_t idx) const -> T {
        return [: expand_all(ptr_mems) :] >> [this, idx]<auto... M>{
            return T{pointers_.[:M:][idx]...};
        };
    }
};
```
{: .line-numbers  }

Needless to say, I'm *very* excited about Reflection.
